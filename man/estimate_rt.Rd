% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimate_rt.R
\name{estimate_rt}
\alias{estimate_rt}
\title{Estimate Rt using smoothness-penalized Poisson likelihood}
\usage{
estimate_rt(
  observed_counts,
  degree = 3L,
  dist_gamma = c(2.5, 2.5),
  x = NULL,
  lambda = NULL,
  nsol = 100L,
  lambdamin = -1,
  lambdamax = 1,
  lambda_min_ratio = 1e-04,
  algo = c("linear_admm", "irls_admm"),
  maxiter = 10000,
  init = NULL
)
}
\arguments{
\item{observed_counts}{vector of the observed daily infection counts}

\item{degree}{Integer. Degree of the piecewise polynomial curve to be
estimated. Ror example, `degree = 0` corresponds to a piecewise constant
curve.}

\item{dist_gamma}{Vector of length 2. These are the shape and scale for the
assumed serial interval distribution. Roughly, this distribution describes
the probability of an infectious individual infecting someone else after
some period of time after having become infectious.
As in most literature, we assume that this interval follows a gamma
distribution with some shape and scale.}

\item{x}{a vector of positions at which the counts have been observed. In an
ideal case, we would observe data at regular intervals (e.g. daily or
weekly) but this may not always be the case.}

\item{lambda}{Vector. A user supplied sequence of tuning parameters which
determines the balance between data fidelity and
smoothness of the estimated Rt; larger `lambda` results in a smoother
estimate. The default, `NULL`
results in an automatic computation based on `nlambda`, the largest value
of `lambda` that would a maximally smooth estimate, and `lambdamin_ratio`.
Supplying a value of `lambda` overrides
this behaviour. It is likely better to supply a
decreasing sequence of `lambda` values than a single (small) value. If
supplied, the user-defined `lambda` sequence is automatically sorted in
decreasing order.}

\item{lambdamin}{Optional value for the smallest `lambda` to use. This should
be greater than zero.}

\item{lambdamax}{Optional value for the largest `lambda` to use.}

\item{algo}{the algorithm to be used in computation. `linear_admm`:
linearized ADMM; `irls_admm`: iteratively reweighted least squares with
standard ADMM.}

\item{maxiter}{Integer. Maximum number of iterations for the estimation
algorithm.}

\item{init}{a list of internal configuration parameters of class
`rt_admm_configuration`.}

\item{nlambda}{Integer. The number of tuning parameters `lambda` at which to
compute Rt.}

\item{lambdamin_ratio}{If neither `lambda` nor `lambdamin` is specified, the
program will generate a lambdamin by lambdamax * lambda_min_ratio
A multiplicative factor for the minimal lambda in the
`lambda` sequence, where `lambdamin = lambdamin_ratio * lambdamax`.
A very small value will lead to the solution `Rt = log(observed_counts)`.
This argument has no effect if there is user-defined `lambda` sequence.}
}
\value{
An object with S3 class `"poison_rt"`. Among the list components:
* `observed_counts` the observed daily infection counts
* `weighted_past_counts` the weighted sum of past infection counts
* `R` the estimated effective reproduction rate. This is a matrix with
    each column corresponding to one value of `lambda`.
* `lambda` the value of `lambda` actually used in the algorithm.
* `niter` the required number of iterations for each value of `lambda`
* `convr` if the model converges `convr==TRUE` or not `convr==FALSE`
}
\description{
The Effective Reproduction Number \eqn{R_t} of an infectious
disease can be estimated by solving the smoothness penalized Poisson
regression of the form:

\eqn{R_t = argmin_{\theta} (\frac{1}{n} \sum_{i=1}^n e^{\theta_i} -
  y_i\theta_i) + \lambda||D^{(k+1)}\theta||_1}

where \eqn{y_i} is the observed case count at day \eqn{i},
\eqn{\theta_i = \sum_{a=1}y_{a}w_{t-a}} is the weighted past counts
at day \eqn{i}, \eqn{\lambda} is the smoothness penalty, and \eqn{D^{(k+1)}}
is the \eqn{(k+1)}-th order difference matrix.
}
\examples{
y <- c(rev(seq(2, 6, by = 1)), seq(2, 6, by = 1))
estimate_rt(
  observed_counts = y, degree = 2, lambda = .1,
  algo = "linear_admm",
  init = rt_admm_configuration(y, degree = 1)
)
}
