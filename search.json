[{"path":"https://dajmcdon.github.io/rtestim/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 rtestim authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://dajmcdon.github.io/rtestim/articles/delay-distributions.html","id":"discretization","dir":"Articles","previous_headings":"","what":"Discretization","title":"Delay distributions","text":"First, important recognize sequence \\(\\{w\\}_{=1}^n\\) usually discretization probability density function, frequently gamma Weibull. observed incidence happens discrete time points like days weeks, time continuous. Using default (parametric) delay distributions requires calculating discrete approximation.","code":""},{"path":"https://dajmcdon.github.io/rtestim/articles/delay-distributions.html","id":"default-parametric-delay-distribution","dir":"Articles","previous_headings":"","what":"Default (parametric) delay distribution","title":"Delay distributions","text":"default, estimate_rt() uses gamma distribution parameterized shape \\(k\\) scale \\(\\theta\\). density pdf \\[ f_W(w) = \\frac{1}{\\Gamma(k)\\theta^k} w^{k-1} e^{-w/\\theta} (w > 0), \\] \\(\\) indicator function. mean distribution \\(k\\theta\\), variance \\(k\\theta^2\\). \\(k\\) \\(\\theta\\) must greater 0. figure shows examples densities family.  default orange curve shown . Given incidence sequence length \\(n\\), internally, delay_calculator() creates \\(\\{w\\}_{=1}^n\\) \\[ w_a = F() - F(- 1), \\] renormalizing w / sum(w) ensure sums 1. , \\(F\\) cumulative distribution function Gamma (though similar works continuous distribution). Note formula assumes probability 0 delay 0 probability delay \\(\\) really \\[ \\int_{-1}^f_W(w) \\, dw = F() - F(-1). \\] using default, delay distribution necessarily assumed \\(t\\), compute convolution w Fast Fourier Transform. Finally, adjustment made handle first observation. define \\(I_0 = I_1\\). Just illustrate behaviour, show results default setting included cancovid data.","code":"can_default <- estimate_rt(cancovid$incident_cases, x = cancovid$date, nsol = 20L) plot(can_default) + coord_cartesian(ylim = c(0.5, 2))"},{"path":"https://dajmcdon.github.io/rtestim/articles/delay-distributions.html","id":"constant-non-parametric-delay-distribution","dir":"Articles","previous_headings":"","what":"Constant, non-parametric delay distribution","title":"Delay distributions","text":"don’t believe Gamma distribution closely approximates serial interval distribution, can specify distribution manually. example, Backer et al., Table S1 gives observed serial intervals Omicron (SGTF) Delta (non-SGTF) COVID-19 variants 2 weeks 2021 Netherlands. sake illustration, aggregate together use (constant) delay distribution.  distribution looks something like gamma, finite support. can easily use instead.  result much less dramatic previous version. likely distribution much concentrated near short delays. can see examining two CDFs.","code":"# Data from Backer et al. delay <- read.csv(\"backer.csv\") |>   filter(delay > 0) |>   select(-delay) delay <- rowSums(delay) delay <- delay / sum(delay) can_nonpar <- estimate_rt(   cancovid$incident_cases,    x = cancovid$date,    delay_distn = delay,   nsol = 20L) plot(can_nonpar) + coord_cartesian(ylim = c(0.5, 2))"},{"path":"https://dajmcdon.github.io/rtestim/articles/delay-distributions.html","id":"time-varying-delays","dir":"Articles","previous_headings":"","what":"Time-varying delays","title":"Delay distributions","text":"Finally, also allow time-varying delay distributions. accomplished matrix. requires bit work, challenging. example, create correct matrix using Baker et al. delays, necessary code following. simply pass delay_mat estimate_rt(..., delay_distn = delay_mat). result shown .","code":"# library(Matrix) n <- nrow(cancovid) backer_delay <- c(0, delay, rep(0, n - length(delay) - 1)) delay_mat <- matrix(0, n, n) delay_mat[1,1] <- 1 for (iter in 2:n) delay_mat[iter, 1:iter] <- rev(backer_delay[1:iter]) delay_mat <- drop0(as(delay_mat, \"CsparseMatrix\")) # make it sparse, not necessary delay_mat <- delay_mat / rowSums(delay_mat) # renormalize"},{"path":"https://dajmcdon.github.io/rtestim/articles/delay-distributions.html","id":"variant-specific-delays","dir":"Articles","previous_headings":"","what":"Variant-specific delays","title":"Delay distributions","text":"illustrative version previous example, revisit Canadian data, combine additional information. use variant circulation information CoVaRR-Net’s Duotang notebook. simplicity, code processing hidden fold. smooth raw data using multinomial logistic regression third order orthogonal polynomial produce following estimated variant proportions Canada.  Using estimated proportions, label date dominant variant time (restrict time period included case data).","code":"# Run on 19 April 2024 duotang <- read_tsv(\"https://github.com/CoVaRR-NET/duotang/raw/main/data_needed/virusseq.metadata.csv.gz\") columnlist <- c(   \"fasta_header_name\", \"province\", \"host_gender\", \"host_age_bin\",   \"sample_collection_date\", \"sample_collected_by\",   \"purpose_of_sampling\", \"purpose_of_sequencing\", \"lineage\",   \"raw_lineage\", \"gisaid_accession\", \"isolate\" ) unknown.str <- c(   \"Undeclared\", \"Not Provided\", \"Restricted Access\", \"Missing\",   \"Not Applicable\", \"\", \"NA\", \"unknow\" ) duotang <- duotang |>   rename(province = geo_loc_name_state_province_territory) |>   select(all_of(columnlist))  meta <- duotang |>   mutate(     week = cut(sample_collection_date, \"week\"),     month = gsub(\"-..$\", \"\", as.character(cut(sample_collection_date, \"month\")))   ) source(\"https://github.com/CoVaRR-NET/duotang/raw/main/scripts/scanlineages.R\") meta <- meta |>   mutate(gisaid_accession = str_replace(gisaid_accession, \"EPI_ISL_\", \"\")) |>   rename(GID = gisaid_accession) |>   rowwise() |>   mutate(raw_lineage = ifelse(     grepl(\"^X\", raw_lineage),     str_replace_all(paste0(       realtorawlineage(substr(         raw_lineage, 1, str_locate(raw_lineage, \"\\\\.\") - 1       )),       \".\",       substr(raw_lineage, str_locate(raw_lineage, \"\\\\.\") + 1, nchar(raw_lineage))     ), \"[\\r\\n]\", \"\"),     raw_lineage   )) |>   ungroup() dico <- makepangolindico() # rebuild the lineage dictionary so the correct names gets assigned for XBB descedants not named XBB  VOCVOI <- read_csv(\"https://raw.githubusercontent.com/CoVaRR-NET/duotang/main/resources/vocvoi.csv\") meta$pango_group <- create.pango.group(VOCVOI, meta) meta <- select(meta, province, week, pango_group) |>   mutate(week = as.Date(week))  counts <- group_by(meta, province, week, pango_group) |>   count() |>   ungroup() |>   arrange(province, week, pango_group) can_counts <- group_by(meta, week, pango_group) |>   count() |>   ungroup() |>   arrange(week, pango_group) |>   mutate(province = \"Canada\") counts <- bind_rows(can_counts, counts) saveRDS(counts, \"duotang-counts.rds\")"},{"path":"https://dajmcdon.github.io/rtestim/articles/delay-distributions.html","id":"creating-delay-distributions","dir":"Articles","previous_headings":"","what":"Creating delay distributions","title":"Delay distributions","text":"use delay distribution data meta analysis Xu, X., Wu, Y., Kummer, .G. et al.. raw data analysis available GitHub. use simple version procedure, taking median calculations across studies find mean standard deviation delay variant separately. convert \\(k\\) \\(\\theta\\) parameters gamma distribution. analysis hidden fold. ’ll use just Serial Intervals (SI), though incubation periods (IP), generation times (GT) also available. , visualize estimated delays 4 variants prevalent Canada.  use delays period prevalent estimate Rt. First, build delay matrix. Finally, use time-varying delay matrix estimate Rt.","code":"data_raw <- readxl::read_excel(\"xu-etal-DATA_RAW.xlsx\") |>   select(type, para, n = Sample_size, mean, sd, se, median) |>   filter(!is.na(type)) |>   mutate(across(-c(type, para), as.numeric))   bonehead_meta <- data_raw |>   group_by(type, para) |>   mutate(     no_n = all(is.na(n)),     n = case_when(!is.na(n) ~ n, no_n ~ 1, TRUE ~ median(n, na.rm = TRUE))   ) |>   ungroup() |>   mutate(     mean = case_when(!is.na(mean) ~ mean, TRUE ~ median),     sd = case_when(!is.na(sd) ~ sd, TRUE ~ se * sqrt(n))   ) |>   group_by(type, para) |>   summarise(     mean = median(mean, na.rm = TRUE),     sd = median(sd, na.rm = TRUE),     .groups = \"drop\"   ) ## There's only one Beta and only IP.  ## We use the corresponding sd for Alpha IP,  ## and duplicate Alpha for GT / ST  Beta_IP <- bonehead_meta |> filter(type == \"Beta\") Beta_IP$sd = bonehead_meta |>    filter(type == \"Alpha\", para == \"IP\") |> pull(sd) Beta <- bind_rows(   Beta_IP,   bonehead_meta |>      filter(type == \"Alpha\", para != \"IP\") |>     mutate(type = \"Beta\") )  delay_dstns_byvar <- bonehead_meta |>   filter(type != \"Beta\") |>   bind_rows(Beta) |>   arrange(type, para) |>   mutate(shape = mean^2 / sd^2, scale = mean / shape) saveRDS(delay_dstns_byvar, \"delay-distns-byvar.rds\") library(Matrix) n <- nrow(cancovid) delay_mat <- matrix(0, n, n) delay_mat[1,1] <- 1 for (iter in 2:n) {   current_var <- can_pred_class$var[iter]   current_pars <- delay_dstns_can |> filter(type == current_var)   delay <- discretize_gamma(0:(iter - 1), current_pars$shape, current_pars$scale)   delay_mat[iter, 1:iter] <- rev(delay) } delay_mat <- drop0(as(delay_mat, \"CsparseMatrix\")) # make it sparse, not necessary delay_mat <- delay_mat / rowSums(delay_mat) # renormalize can_tvar <- estimate_rt(   cancovid$incident_cases,    x = cancovid$date,    delay_distn = delay_mat,   nsol = 20L) plot(can_tvar) + coord_cartesian(ylim = c(0.5, 2))"},{"path":"https://dajmcdon.github.io/rtestim/articles/rtestim.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"rtestim Package Vignette","text":"package uses Poisson likelihood trend filtering penalty (type regularized nonparametric regression) estimate effective reproductive number, \\(R_t\\). value roughly says “many new infections result new infection today”. Values larger 1 indicate epidemic growing less 1 indicate decline. vignette provides examples demonstrate usage rtestim estimate effective reproduction number, \\(R_t\\). rtestim finds sequence \\(R_t\\), \\(\\{R_t\\}_{t=1}^n\\) infectious disease solving following penalized Poisson regression \\[\\begin{equation} \\label{eq:objective_fn}     \\hat{\\theta} = \\mathop{\\mathrm{argmin}}_{\\theta} \\frac{1}{n} \\sum_{t=1}^n \\left(e^{\\theta_{t}}x_t - y_t\\theta_{t}\\right) + \\lambda \\Vert D^{(k+1)} \\theta \\Vert_1 \\end{equation}\\] \\(y_t\\) epidemic signal, ideally, incident infections, frequently, incident cases, day \\(t\\), \\(\\theta_{t} = \\log(R_t)\\) natural logarithm \\(R_t\\) time \\(t\\), \\(D^{(k)}\\) \\(k\\)-th order divided difference operator (\\(k \\geq 0\\)). penalty \\(\\Vert D^{(k+1)} \\theta \\Vert_1\\) imposes smoothness solution \\(\\lambda\\) controls level smoothness, larger \\(\\lambda\\) resulting smoother estimates. particular \\[\\begin{equation} x_t = \\sum_{= 1}^m y_{t-} w_a \\end{equation}\\] weighted sum previous incidence \\(t\\), calculated convolving preceding \\(m\\) days new infections discretized serial interval distribution \\(w\\) length \\(m\\). delay distribution encapsulates duration time previous infection likely lead future infection. compute \\(\\{R_t\\}_{t=1}^n\\) rtestim, minimal information needed new case counts days \\(t\\) parametric form serial interval distribution (Gamma density). default, \\(2.5\\) used scale shape parameters, based literature contract tracing, representing typical delay case onsets. discretized supported integers. order difference operator, degree smoothness, defaults \\(3\\). sequence smoothness penalty \\(\\lambda\\), \\(\\lambda\\) provided, calculated internally algorithm.","code":""},{"path":[]},{"path":"https://dajmcdon.github.io/rtestim/articles/rtestim.html","id":"quick-start","dir":"Articles","previous_headings":"Example - synthetic dataset","what":"Quick start","title":"rtestim Package Vignette","text":"first demonstrate usage package synthetic data, new daily case counts generated Poisson distribution mean parameter roughly follows wave. Note first observation must strictly larger 0.  Next, fit model visualize resulting \\(\\{R_t\\}_{t=1}^n\\):  rtestim estimates spectrum \\(\\{R_t\\}_{t=1}^n\\)s range \\(\\lambda\\) values, \\(\\{R_t\\}_{t=1}^n\\) corresponds specific \\(\\lambda\\) value. \\(\\lambda\\) value supplied user, rtestim automatically calculate sequence \\(\\lambda\\) values. additional parameter nsol = 20 specifies number \\(\\lambda\\)s \\(\\{R_t\\}_{t=1}^n\\) calculated","code":"set.seed(12345) case_counts <- c(1, rpois(100, dnorm(1:100, 50, 15) * 500 + 1)) ggplot(data.frame(x = 1:101, case_counts), aes(x, case_counts)) +   geom_point(colour = \"cornflowerblue\") +   labs(x = \"Time\", y = \"Case Counts\") mod <- estimate_rt(observed_counts = case_counts, nsol = 20) plot(mod)"},{"path":"https://dajmcdon.github.io/rtestim/articles/rtestim.html","id":"cross-validation","dir":"Articles","previous_headings":"Example - synthetic dataset","what":"Cross Validation","title":"rtestim Package Vignette","text":"rtestim also provides cross validation procedure selecting amount smoothness used final estimate (leave-every-k-th-cross validation). Minimizing metric, principle, balances prediction error smoothness (lambda.min) though smoother estimates desired, one can instead use lambda.1se, largest value \\(\\lambda\\) within one standard error minimum. following command plots cross validation errors \\(\\lambda\\) ascending order.  plot displays vertical lines correspond cross-validation scores specific values \\(\\lambda\\). blue point center line represents mean score value \\(\\lambda\\) across cross-validation folds. top bottom caps line indicate one cross-validation standard error mean score given value \\(\\lambda\\) across cross-validation folds. Two special values \\(\\lambda\\)’s highlighted dashed lines. one left represents \\(\\lambda\\) gives minimum mean cross-validated error, called lambda.min, one right gives regularized model cross-validated error within one standard error minimum, called lambda.1se. Users may wish visualize particular \\(\\{R_t\\}_{t=1}^n\\) minimizes cross-validation error prioritizing smoothness.","code":"mod_cv <- cv_estimate_rt(observed_counts = case_counts) plot(mod_cv) plot(mod_cv, which_lambda = \"lambda.1se\")"},{"path":"https://dajmcdon.github.io/rtestim/articles/rtestim.html","id":"uneven-reporting-frequency","dir":"Articles","previous_headings":"Example - synthetic dataset","what":"Uneven Reporting Frequency","title":"rtestim Package Vignette","text":"Ideally, case counts observed regular intervals, daily weekly, always case. rtestim also accommodates scenarios cases reported uneven intervals. demonstrate , generate sequence integers representing days observe case counts. can fit model passing observation time point x.","code":"observation_incr <- rpois(101, lambda = 2) observation_incr[observation_incr == 0] <- 1 observation_time <- cumsum(observation_incr) mod <- estimate_rt(observed_counts = case_counts, x = observation_time) plot(mod) + coord_cartesian(ylim = c(0, 5))"},{"path":"https://dajmcdon.github.io/rtestim/articles/rtestim.html","id":"changing-degree-of-difference-operator","dir":"Articles","previous_headings":"Example - synthetic dataset","what":"Changing degree of difference operator","title":"rtestim Package Vignette","text":"degree estimated penalized Poisson regression function \\(k\\) defaults 3 algorithm, corresponds piece-wise cubic estimate \\(\\{R_t\\}_{t=1}^n\\). estimate \\(\\{R_t\\}_{t=1}^n\\) piece-wise constant curves example, use command","code":"mod <- estimate_rt(observed_counts = case_counts, korder = 0, nsol = 20) plot(mod)"},{"path":"https://dajmcdon.github.io/rtestim/articles/rtestim.html","id":"example---canadian-covid-19-cases","dir":"Articles","previous_headings":"","what":"Example - Canadian Covid-19 cases","title":"rtestim Package Vignette","text":"Finally, use long history real case counts Canada. data available opencovid.ca version downloaded 4 July 2023 included package. use data estimate \\(R_t\\).","code":"can <- estimate_rt(   observed_counts = cancovid$incident_cases,   x = cancovid$date,   korder = 2,   nsol = 20,   maxiter = 1e5 )  plot(can) + coord_cartesian(ylim = c(0.5, 2))"},{"path":"https://dajmcdon.github.io/rtestim/articles/rtestim.html","id":"approximate-confidence-bands","dir":"Articles","previous_headings":"Example - Canadian Covid-19 cases","what":"Approximate confidence bands","title":"rtestim Package Vignette","text":"also provide functionality computing approximate confidence bands Rt based normal approximations delta method. intended fast provide idea uncertainty, likely don’t guaranteed coverage.","code":"can_cb <- confband(can, lambda = can$lambda[10], level = c(.5, .8, .95)) can_cb #> An `rt_confidence_band` object. #>  #> * type = Rt  #> * lambda = 8320.382  #> * degrees of freedom = 10  #>  #> # A tibble: 1,253 × 7 #>      fit `2.5%` `10.0%` `25.0%` `75.0%` `90.0%` `97.5%` #>    <dbl>  <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> #>  1  2.00  0.837    1.24    1.60    2.40    2.76    3.16 #>  2  1.98  0.922    1.29    1.62    2.34    2.67    3.04 #>  3  1.96  0.940    1.29    1.61    2.31    2.63    2.98 #>  4  1.94  0.899    1.26    1.58    2.30    2.62    2.98 #>  5  1.92  0.832    1.21    1.55    2.30    2.64    3.02 #>  6  1.91  0.766    1.16    1.51    2.30    2.65    3.05 #>  7  1.89  0.710    1.12    1.48    2.29    2.66    3.07 #>  8  1.87  0.661    1.08    1.45    2.29    2.66    3.08 #>  9  1.85  0.615    1.04    1.43    2.28    2.66    3.09 #> 10  1.84  0.563    1.00    1.40    2.27    2.67    3.11 #> # ℹ 1,243 more rows plot(can_cb) + coord_cartesian(ylim = c(0.5, 2))"},{"path":"https://dajmcdon.github.io/rtestim/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Daniel J. McDonald. Author, maintainer, copyright holder. Jiaping Liu. Author. Zhenglun Cai. Contributor.","code":""},{"path":"https://dajmcdon.github.io/rtestim/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"McDonald D, Liu J (2025). rtestim: Estimate Effective Reproductive Number Trend Filtering. R package version 1.0.0.9001, https://github.com/dajmcdon/rtestim.","code":"@Manual{,   title = {rtestim: Estimate the Effective Reproductive Number with Trend Filtering},   author = {Daniel J. McDonald and Jiaping Liu},   year = {2025},   note = {R package version 1.0.0.9001},   url = {https://github.com/dajmcdon/rtestim}, }"},{"path":"https://dajmcdon.github.io/rtestim/index.html","id":"rtestim-","dir":"","previous_headings":"","what":"Estimate the Effective Reproductive Number with Trend Filtering","title":"Estimate the Effective Reproductive Number with Trend Filtering","text":"package uses Poisson likelihood trend filtering penalty (type regularized nonparametric regression) estimate effective reproductive number, Rt. value roughly says “many new infections result new infection today”. Values larger 1 indicate epidemic growing less 1 indicate decline.","code":""},{"path":"https://dajmcdon.github.io/rtestim/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimate the Effective Reproductive Number with Trend Filtering","text":"can install development version rtestim GitHub : released version CRAN","code":"# install.packages(\"remotes\") remotes::install_github(\"dajmcdon/rtestim\") install.packages(\"rtestim\")"},{"path":"https://dajmcdon.github.io/rtestim/index.html","id":"quick-example","dir":"","previous_headings":"","what":"Quick example","title":"Estimate the Effective Reproductive Number with Trend Filtering","text":"create data “looks” like typical wave epidemic. model uses regularized regression, estimate model range tuning parameters simultaneously.  fit model visualize resulting estimated sequences \\(R_t\\):  additional parameter nsol = 20 specifies number tuning parameters \\(R_t\\) estimated. built function cross-validation can used select tuning parameter.","code":"set.seed(12345) library(rtestim) library(ggplot2) dat <- data.frame(   Time = 1:101,   incident_cases = c(1, rpois(100, dnorm(1:100, 50, 15) * 500 + 1)) ) ggplot(dat, aes(Time, incident_cases)) +   geom_point(colour = \"cornflowerblue\") +   theme_bw() mod <- estimate_rt(observed_counts = dat$incident_cases, nsol = 20) plot(mod) mod_cv <- cv_estimate_rt(dat$incident_cases, nsol = 20) plot(mod_cv, which_lambda = \"lambda.1se\")"},{"path":"https://dajmcdon.github.io/rtestim/reference/cancovid.html","id":null,"dir":"Reference","previous_headings":"","what":"Canadian Incident COVID-19 Cases — cancovid","title":"Canadian Incident COVID-19 Cases — cancovid","text":"dataset contains 3+ years incident COVID-19 case counts reported opencovid.ca July 4, 2023.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/cancovid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Canadian Incident COVID-19 Cases — cancovid","text":"","code":"cancovid"},{"path":"https://dajmcdon.github.io/rtestim/reference/cancovid.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Canadian Incident COVID-19 Cases — cancovid","text":"data frame 1,253 rows 2 columns: date observed date. Date object. incident_cases number new recorded cases date.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/cancovid.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Canadian Incident COVID-19 Cases — cancovid","text":"data available CC--4.0 License. See: Berry, ., O’Neill, M., Sturrock, S. L., Wright, J. E., Acharya, K., Brankston, G., Harish, V., Kornas, K., Maani, N., Naganathan, T., Obress, L., Rossi, T., Simmons, . E., Van Camp, M., Xie, X., Tuite, . R., Greer, . L., Fisman, D. N., & Soucy, J.-P. R. (2021). sub-national real-time epidemiological vaccination database COVID-19 pandemic Canada. Scientific Data, 8(1). doi:10.1038/s41597-021-00955-2","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/confband.html","id":null,"dir":"Reference","previous_headings":"","what":"Add confidence bands to estimated Rt or incidence curves — confband","title":"Add confidence bands to estimated Rt or incidence curves — confband","text":"Create approximate confidence band Rt incidence estimate. Note variance computation approximate.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/confband.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add confidence bands to estimated Rt or incidence curves — confband","text":"","code":"confband(object, lambda, level = 0.95, type = c(\"Rt\", \"Yt\"), ...)"},{"path":"https://dajmcdon.github.io/rtestim/reference/confband.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add confidence bands to estimated Rt or incidence curves — confband","text":"object poisson_rt cv_poisson_rt object. lambda selected lambda. May scalar value, case cv_poisson_rt objects, \"lambda.min\" \"lambda.max\". level desired confidence level(s). sorted necessary. type type Rt Yt confidence intervals fitted Rt fitted incident cases ... additional arguments methods. Unused.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/confband.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add confidence bands to estimated Rt or incidence curves — confband","text":"data.frame containing estimates Rt Yt chosen lambda, confidence limits corresponding level","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/confband.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add confidence bands to estimated Rt or incidence curves — confband","text":"","code":"y <- c(1, rpois(100, dnorm(1:100, 50, 15) * 500 + 1)) out <- estimate_rt(y, nsol = 10) head(confband(out, out$lambda[2])) #> An `rt_confidence_band` object. #>  #> * type = Rt  #> * lambda = 106.962  #> * degrees of freedom = 4  #>  #> # A tibble: 6 × 3 #>     fit `2.5%` `97.5%` #>   <dbl>  <dbl>   <dbl> #> 1 0.842 0         2.33 #> 2 0.887 0         1.81 #> 3 0.932 0.0111    1.85 #> 4 0.977 0         1.99 #> 5 1.02  0         2.10 #> 6 1.06  0         2.14 head(confband(out, out$lambda[2], level = c(0.95, 0.8, 0.5))) #> An `rt_confidence_band` object. #>  #> * type = Rt  #> * lambda = 106.962  #> * degrees of freedom = 4  #>  #> # A tibble: 6 × 7 #>     fit `2.5%` `10.0%` `25.0%` `75.0%` `90.0%` `97.5%` #>   <dbl>  <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> #> 1 0.842 0        0       0.336    1.35    1.81    2.33 #> 2 0.887 0        0.289   0.573    1.20    1.49    1.81 #> 3 0.932 0.0111   0.333   0.618    1.25    1.53    1.85 #> 4 0.977 0        0.321   0.633    1.32    1.63    1.99 #> 5 1.02  0        0.322   0.654    1.39    1.72    2.10 #> 6 1.06  0        0.363   0.696    1.43    1.76    2.14  cv <- cv_estimate_rt(y, nfold = 3, nsol = 30) head(confband(cv, \"lambda.min\", c(0.5, 0.9))) #> An `rt_confidence_band` object. #>  #> * type = Rt  #> * lambda = 23.455  #> * degrees of freedom = 4  #>  #> # A tibble: 6 × 5 #>     fit   `5%` `25%` `75%` `95%` #>   <dbl>  <dbl> <dbl> <dbl> <dbl> #> 1 0.779 0      0.290  1.27  1.98 #> 2 0.839 0.0489 0.517  1.16  1.63 #> 3 0.899 0.0625 0.558  1.24  1.74 #> 4 0.960 0.0856 0.604  1.32  1.83 #> 5 1.02  0.0836 0.638  1.40  1.96 #> 6 1.08  0.0938 0.678  1.48  2.07"},{"path":"https://dajmcdon.github.io/rtestim/reference/configure_rt_admm.html","id":null,"dir":"Reference","previous_headings":"","what":"Rt estimation algorithm configuration — configure_rt_admm","title":"Rt estimation algorithm configuration — configure_rt_admm","text":"Rt estimation algorithm configuration","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/configure_rt_admm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rt estimation algorithm configuration — configure_rt_admm","text":"","code":"configure_rt_admm(   rho = -1,   alpha = 0.5,   gamma = 0.9,   tolerance = 1e-04,   maxiter_newton = 50L,   maxiter_line = 20L,   verbose = 0,   ... )"},{"path":"https://dajmcdon.github.io/rtestim/reference/configure_rt_admm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rt estimation algorithm configuration — configure_rt_admm","text":"rho Double. ADMM parameter; coefficient augmented term Lagrangian function. alpha Double. parameter adjusting upper bound line search algorithm prox_newton algorithm. gamma Double. parameter adjusting step size line search algorithm prox_newton algorithm. tolerance Double. Tolerance ADMM convergence. maxiter_newton Integer. Maximum number iterations outer Newton iteration. maxiter_line Integer. Maximum number iterations linesearch algorithm proximal Newton method. verbose Integer. ... space future extensions","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/configure_rt_admm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rt estimation algorithm configuration — configure_rt_admm","text":"list model parameters class rt_admm_configuration","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/configure_rt_admm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rt estimation algorithm configuration — configure_rt_admm","text":"","code":"configure_rt_admm() #>  #> ── An Rt ADMM configuration ── #>  #> rho: -1 #> alpha: 0.5 #> gamma: 0.9 #> tolerance: 1e-04 #> maxiter_newton: 50 #> maxiter_line: 20 #> verbose: 0 configure_rt_admm(tolerance = 1e-6, verbose = 1L) #>  #> ── An Rt ADMM configuration ── #>  #> rho: -1 #> alpha: 0.5 #> gamma: 0.9 #> tolerance: 1e-06 #> maxiter_newton: 50 #> maxiter_line: 20 #> verbose: 1"},{"path":"https://dajmcdon.github.io/rtestim/reference/cv_estimate_rt.html","id":null,"dir":"Reference","previous_headings":"","what":"Leave-kth-out cross validation for choosing a optimal parameter lambda — cv_estimate_rt","title":"Leave-kth-out cross validation for choosing a optimal parameter lambda — cv_estimate_rt","text":"Leave-kth-cross validation choosing optimal parameter lambda","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/cv_estimate_rt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Leave-kth-out cross validation for choosing a optimal parameter lambda — cv_estimate_rt","text":"","code":"cv_estimate_rt(   observed_counts,   korder = 3L,   dist_gamma = c(2.5, 2.5),   nfold = 3L,   error_measure = c(\"deviance\", \"mse\", \"mae\"),   x = 1:n,   lambda = NULL,   maxiter = 1000000L,   delay_distn = NULL,   delay_distn_periodicity = NULL,   regular_splits = FALSE,   invert_splits = FALSE,   ... )"},{"path":"https://dajmcdon.github.io/rtestim/reference/cv_estimate_rt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Leave-kth-out cross validation for choosing a optimal parameter lambda — cv_estimate_rt","text":"observed_counts vector observed daily infection counts korder Integer. Degree piecewise polynomial curve estimated. example, korder = 0 corresponds piecewise constant curve. dist_gamma Vector length 2. shape scale assumed serial interval distribution. Roughly, distribution describes probability infectious individual infecting someone else period time become infectious. literature, assume interval follows gamma distribution shape scale. nfold Integer. number folds conduct leave-kth-cross validation. leave-kth-cross validation, every kth observed_counts corresponding position (evenly unevenly spaced) placed fold. first last observed_counts assigned folds. Smallest allowable value nfold = 2. error_measure Metric used calculate cross validation scores. Must choose mse, mae, deviance. mse calculates mean square error; mae calculates mean absolute error; deviance calculates deviance x vector positions counts observed. ideal case, observe data regular intervals (e.g. daily weekly) may always case. May numeric Date. lambda Vector. user supplied sequence tuning parameters determines balance data fidelity smoothness estimated Rt; larger lambda results smoother estimate. default, NULL results automatic computation based nlambda, largest value lambda result maximally smooth estimate, lambda_min_ratio. Supplying value lambda overrides behaviour. likely better supply decreasing sequence lambda values single (small) value. supplied, user-defined lambda sequence automatically sorted decreasing order. maxiter Integer. Maximum number iterations estimation algorithm. delay_distn case non-gamma delay distribution, vector matrix (Matrix::Matrix()) delay probabilities may passed . vector, coerced sum 1, padded 0 right tail necessary. time-varying delay matrix, must lower-triangular. row silently coerced sum 1. See also vignette(\"delay-distributions\"). delay_distn_periodicity Controls relationship spacing computed delay distribution spacing x. default case, x regular sequence 1:length(observed_cases), 1. x Date object spaced irregularly, relationship becomes complicated. example, weekly data x date form YYYY-MM-DD requires specifying delay_distn_periodicity = \"1 week\". observed_cases reported Monday, Wednesday, Friday, delay_distn_periodicity = \"1 day\" appropriate. regular_splits Logical. TRUE, folds k-fold cross-validation chosen placing every kth point fold. first last points included fold always included building predictive model. example, 15 data points kfold = 4, points assigned folds following way: $$   0 \\; 1 \\; 2 \\; 3 \\; 4 \\; 1 \\; 2 \\; 3 \\;  4 \\; 1 \\; 2 \\; 3 \\; 4 \\; 1 \\; 0   $$ 0 indicates assignment. Therefore, folds random running cv_estimate_rt() twice give result. invert_splits Logical. Typical K-fold CV use K-1 folds training set reserving 1 fold evaluation (repeating split K times). Setting true inverts process, using much smaller training set larger evaluation set. tends result larger values lambda minimize CV. ... additional parameters passed estimate_rt() function","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/cv_estimate_rt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Leave-kth-out cross validation for choosing a optimal parameter lambda — cv_estimate_rt","text":"object S3 class \"cv_poisson_rt\". Among list components: full_fit object S3 class \"poisson_rt\", fitted observed_counts lambda cv_scores leave-kth-cross validation scores cv_se leave-kth-cross validation standard error lambda.min lambda achieved optimal cross validation score lambda.1se lambda gives optimal cross validation score within one standard error. lambda value lambda used algorithm.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/cv_estimate_rt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Leave-kth-out cross validation for choosing a optimal parameter lambda — cv_estimate_rt","text":"","code":"y <- c(1, rpois(100, dnorm(1:100, 50, 15) * 500 + 1)) cv <- cv_estimate_rt(y, korder = 3, nfold = 3, nsol = 30) cv #>  #> Call: cv_estimate_rt(observed_counts = y, korder = 3, nfold = 3, nsol = 30) #>  #> Degree of the estimated piecewise polynomial curve: 3  #>  #> Summary of cross validation across lambda: #>                 lambda index cv_scores  cv_se dof #> Max Lambda   372.65970     1     1.634 0.1761   4 #> 1se Lambda   372.65970     1     1.634 0.1761   4 #> CV Minimizer   8.24404    13     1.438 0.2253   6 #> Min Lambda     0.03727    30     2.558 0.2883  23 #>"},{"path":"https://dajmcdon.github.io/rtestim/reference/delay_calculator.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the total infectiousness at each observed time point. — delay_calculator","title":"Calculate the total infectiousness at each observed time point. — delay_calculator","text":"total infectiousness observed time point calculated \\(\\sum_{s=1}^t I_{t-s}w_s\\), \\(\\) denotes vector containing observed incidence, \\(w\\) denotes generation interval distribution. Typically, generation interval challenging estimate data, serial interval used instead. serial interval distribution expresses probability secondary infection caused primary infection occurred \\(s\\) days earlier.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/delay_calculator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the total infectiousness at each observed time point. — delay_calculator","text":"","code":"delay_calculator(   observed_counts,   x = NULL,   dist_gamma = c(2.5, 2.5),   delay_distn = NULL,   delay_distn_periodicity = NULL,   xout = x )"},{"path":"https://dajmcdon.github.io/rtestim/reference/delay_calculator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the total infectiousness at each observed time point. — delay_calculator","text":"observed_counts vector observed daily infection counts x vector positions counts observed. ideal case, observe data regular intervals (e.g. daily weekly) may always case. May numeric Date. dist_gamma Vector length 2. shape scale assumed serial interval distribution. Roughly, distribution describes probability infectious individual infecting someone else period time become infectious. literature, assume interval follows gamma distribution shape scale. delay_distn case non-gamma delay distribution, vector matrix (Matrix::Matrix()) delay probabilities may passed . vector, coerced sum 1, padded 0 right tail necessary. time-varying delay matrix, must lower-triangular. row silently coerced sum 1. See also vignette(\"delay-distributions\"). delay_distn_periodicity Controls relationship spacing computed delay distribution spacing x. default case, x regular sequence 1:length(observed_cases), 1. x Date object spaced irregularly, relationship becomes complicated. example, weekly data x date form YYYY-MM-DD requires specifying delay_distn_periodicity = \"1 week\". observed_cases reported Monday, Wednesday, Friday, delay_distn_periodicity = \"1 day\" appropriate. xout vector positions results returned. default, x, case observations unequally spaced, alternatives may desired. Note xout must satisfy min(x) <= min(xout) max(x) >= max(xout).","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/delay_calculator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the total infectiousness at each observed time point. — delay_calculator","text":"vector containing total infectiousness point xout.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/delay_calculator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the total infectiousness at each observed time point. — delay_calculator","text":"","code":"delay_calculator(c(3, 2, 5, 3, 1), dist_gamma = c(2.5, 2.5)) #> [1] 3.000000 2.811312 2.828111 3.022142 3.119169"},{"path":"https://dajmcdon.github.io/rtestim/reference/discretize_gamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the discretized density function for gamma distribution — discretize_gamma","title":"Compute the discretized density function for gamma distribution — discretize_gamma","text":"serial interval distribution expresses probability symptom onset secondary infection occurred given number days primary infection. serial interval distribution commonly represented discretized Gamma distribution literature, parametrized shape scale parameters.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/discretize_gamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the discretized density function for gamma distribution — discretize_gamma","text":"","code":"discretize_gamma(x, shape = 2.5, scale = 2.5, rate = 1/scale)"},{"path":"https://dajmcdon.github.io/rtestim/reference/discretize_gamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the discretized density function for gamma distribution — discretize_gamma","text":"x locations (times) cases observed. Must nonnegative. shape, scale shape scale parameters.  Must positive,     scale strictly. rate alternative way specify scale.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/discretize_gamma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the discretized density function for gamma distribution — discretize_gamma","text":"probability mass discretized gamma distribution","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/discretize_gamma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the discretized density function for gamma distribution — discretize_gamma","text":"","code":"discretize_gamma(1:30, shape = 1, scale = 1) #>  [1] 6.321206e-01 2.325442e-01 8.554821e-02 3.147143e-02 1.157769e-02 #>  [6] 4.259195e-03 1.566870e-03 5.764193e-04 2.120528e-04 7.800987e-05 #> [11] 2.869823e-05 1.055749e-05 3.883883e-06 1.428801e-06 5.256264e-07 #> [16] 1.933671e-07 7.113580e-08 2.616940e-08 9.627183e-09 3.541643e-09 #> [21] 1.302898e-09 4.793092e-10 1.763280e-10 6.486749e-11 2.386338e-11 #> [26] 8.778840e-12 3.229589e-12 1.188076e-12 4.370671e-13 1.607855e-13"},{"path":"https://dajmcdon.github.io/rtestim/reference/estimate_rt.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Rt using smoothness-penalized Poisson likelihood — estimate_rt","title":"Estimate Rt using smoothness-penalized Poisson likelihood — estimate_rt","text":"Effective Reproduction Number \\(R_t\\) infectious disease can estimated solving smoothness penalized Poisson regression (trend filtering) form: $$\\hat{\\theta} = \\arg\\min_{\\theta} \\frac{1}{n} \\sum_{=1}^n (w_i e^{\\theta_i} -   y_i\\theta_i) + \\lambda\\Vert D^{(k+1)}\\theta\\Vert_1, $$ \\(R_t = e^{\\theta}\\), \\(y_i\\) observed case count day \\(\\), \\(w_i\\) weighted past counts day \\(\\), \\(\\lambda\\) smoothness penalty, \\(D^{(k+1)}\\) \\((k+1)\\)-th order difference matrix.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/estimate_rt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Rt using smoothness-penalized Poisson likelihood — estimate_rt","text":"","code":"estimate_rt(   observed_counts,   korder = 3L,   dist_gamma = c(2.5, 2.5),   x = 1:n,   lambda = NULL,   nsol = 50L,   delay_distn = NULL,   delay_distn_periodicity = NULL,   lambdamin = NULL,   lambdamax = NULL,   lambda_min_ratio = 1e-04,   maxiter = 1e+05,   init = configure_rt_admm() )"},{"path":"https://dajmcdon.github.io/rtestim/reference/estimate_rt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Rt using smoothness-penalized Poisson likelihood — estimate_rt","text":"observed_counts vector observed daily infection counts korder Integer. Degree piecewise polynomial curve estimated. example, korder = 0 corresponds piecewise constant curve. dist_gamma Vector length 2. shape scale assumed serial interval distribution. Roughly, distribution describes probability infectious individual infecting someone else period time become infectious. literature, assume interval follows gamma distribution shape scale. x vector positions counts observed. ideal case, observe data regular intervals (e.g. daily weekly) may always case. May numeric Date. lambda Vector. user supplied sequence tuning parameters determines balance data fidelity smoothness estimated Rt; larger lambda results smoother estimate. default, NULL results automatic computation based nlambda, largest value lambda result maximally smooth estimate, lambda_min_ratio. Supplying value lambda overrides behaviour. likely better supply decreasing sequence lambda values single (small) value. supplied, user-defined lambda sequence automatically sorted decreasing order. nsol Integer. number tuning parameters lambda compute Rt. delay_distn case non-gamma delay distribution, vector matrix (Matrix::Matrix()) delay probabilities may passed . vector, coerced sum 1, padded 0 right tail necessary. time-varying delay matrix, must lower-triangular. row silently coerced sum 1. See also vignette(\"delay-distributions\"). delay_distn_periodicity Controls relationship spacing computed delay distribution spacing x. default case, x regular sequence 1:length(observed_cases), 1. x Date object spaced irregularly, relationship becomes complicated. example, weekly data x date form YYYY-MM-DD requires specifying delay_distn_periodicity = \"1 week\". observed_cases reported Monday, Wednesday, Friday, delay_distn_periodicity = \"1 day\" appropriate. lambdamin Optional value smallest lambda use. greater zero. lambdamax Optional value largest lambda use. lambda_min_ratio neither lambda lambdamin specified, program generate lambdamin lambdamax * lambda_min_ratio. multiplicative factor minimal lambda lambda sequence, lambdamin = lambda_min_ratio * lambdamax. small value lead solution Rt = log(observed_counts). argument effect user-defined lambda sequence. maxiter Integer. Maximum number iterations estimation algorithm. init list internal configuration parameters class rt_admm_configuration.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/estimate_rt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Rt using smoothness-penalized Poisson likelihood — estimate_rt","text":"object S3 class poisson_rt. Among list components: observed_counts observed daily infection counts. x vector positions counts observed. weighted_past_counts weighted sum past infection counts. Rt estimated effective reproduction rate. matrix column corresponding one value lambda. lambda values lambda actually used algorithm. korder degree estimated piecewise polynomial curve. dof degrees freedom estimated trend filtering problem. niter required number iterations value lambda. convergence number iterations value lambda less maximum number iterations estimation algorithm.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/estimate_rt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Rt using smoothness-penalized Poisson likelihood — estimate_rt","text":"","code":"y <- c(1, rpois(100, dnorm(1:100, 50, 15) * 500 + 1)) out <- estimate_rt(y) out #>  #> Call:  estimate_rt(observed_counts = y) #>  #> Degree of the estimated piecewise polynomial curve: 3  #>  #> Summary of the 50 estimated models: #>  #>           lambda index approx_dof niterations #> Max.    313.3978     1          4          13 #> 3rd Qu.  32.8476    13          4          84 #> Median    2.8529    26          6         525 #> 1st Qu.   0.2990    38         14        1581 #> Min.      0.0313    50         30        2330 #>  plot(out)   out0 <- estimate_rt(y, korder = 0L, nsol = 40) out0 #>  #> Call:  estimate_rt(observed_counts = y, korder = 0L, nsol = 40) #>  #> Degree of the estimated piecewise polynomial curve: 0  #>  #> Summary of the 40 estimated models: #>  #>           lambda index approx_dof niterations #> Max.    7.93e-01     1         77           0 #> 3rd Qu. 7.48e-02    11         86           0 #> Median  8.93e-03    20         86           0 #> 1st Qu. 8.42e-04    30         86           0 #> Min.    7.93e-05    40         86           0 #>  plot(out0)"},{"path":"https://dajmcdon.github.io/rtestim/reference/fitted.cv_poisson_rt.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitted cv_poisson_rt — fitted.cv_poisson_rt","title":"Fitted cv_poisson_rt — fitted.cv_poisson_rt","text":"Fitted cv_poisson_rt","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/fitted.cv_poisson_rt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitted cv_poisson_rt — fitted.cv_poisson_rt","text":"","code":"# S3 method for class 'cv_poisson_rt' fitted(object, which_lambda = c(\"lambda.min\", \"lambda.1se\"), ...)"},{"path":"https://dajmcdon.github.io/rtestim/reference/fitted.cv_poisson_rt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitted cv_poisson_rt — fitted.cv_poisson_rt","text":"object result cross validation type cv_poisson_rt which_lambda select Rt's output. provided, Rt's returned. provided list lambda,corresponding Rt estimation returned. provided string, must either one lambda.min lambda.1se. provided lambda.min, return Rt generated lambda minimizes cross validation score. provided lambda.1se, return Rt generated lambda whose corresponding cross validation score 1 standard error away minimal cross validation score. ... used.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/fitted.cv_poisson_rt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitted cv_poisson_rt — fitted.cv_poisson_rt","text":"Rt's estimated provided lambda","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/fitted.cv_poisson_rt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitted cv_poisson_rt — fitted.cv_poisson_rt","text":"","code":"y <- c(1, rpois(100, dnorm(1:100, 50, 15) * 500 + 1)) cv <- cv_estimate_rt(y, korder = 3, nfold = 3, nsol = 30) f <- fitted(cv) f <- fitted(cv, which_lambda = cv$lambda[1]) f <- fitted(cv, which_lambda = \"lambda.1se\") f <- fitted(cv, which_lambda = NULL)"},{"path":"https://dajmcdon.github.io/rtestim/reference/interpolate_rt.html","id":null,"dir":"Reference","previous_headings":"","what":"Interpolate (or extrapolate) Rt estimates to intermediate design points — interpolate_rt","title":"Interpolate (or extrapolate) Rt estimates to intermediate design points — interpolate_rt","text":"Interpolate (extrapolate) Rt estimates intermediate design points","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/interpolate_rt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interpolate (or extrapolate) Rt estimates to intermediate design points — interpolate_rt","text":"","code":"interpolate_rt(object, xout, ...)  # S3 method for class 'cv_poisson_rt' interpolate_rt(object, xout, which_lambda = c(\"lambda.min\", \"lambda.1se\"), ...)  # S3 method for class 'poisson_rt' interpolate_rt(object, xout, lambda = NULL, ...)"},{"path":"https://dajmcdon.github.io/rtestim/reference/interpolate_rt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interpolate (or extrapolate) Rt estimates to intermediate design points — interpolate_rt","text":"object fitted object produced estimate_rt() cv_estimate_rt(). xout vector new positions Rt produced, counts may observed. ... additional arguments passed methods. which_lambda Select lambdas object use. provided, Rt's returned. Note new lambdas originally used estimation procedure may provided, results calculated linearly interpolating estimated Rt's. strings lambda.min lambda.1se allowed choose either lambda minimizes cross validation score largest lambda whose corresponding cross validation score within 1 standard error minimal cross validation score. lambda Vector. user supplied sequence tuning parameters determines balance data fidelity smoothness estimated Rt; larger lambda results smoother estimate. default, NULL results automatic computation based nlambda, largest value lambda result maximally smooth estimate, lambda_min_ratio. Supplying value lambda overrides behaviour. likely better supply decreasing sequence lambda values single (small) value. supplied, user-defined lambda sequence automatically sorted decreasing order.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/interpolate_rt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interpolate (or extrapolate) Rt estimates to intermediate design points — interpolate_rt","text":"vector matrix interpolated Rt estimates.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/interpolate_rt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interpolate (or extrapolate) Rt estimates to intermediate design points — interpolate_rt","text":"","code":"y <- c(1, rpois(100, dnorm(1:100, 50, 15) * 500 + 1)) out <- estimate_rt(y)  # originally estimated at out$x #>   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18 #>  [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36 #>  [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54 #>  [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72 #>  [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90 #>  [91]  91  92  93  94  95  96  97  98  99 100 101  # get the Rt at 3 new points (for all estimated lambdas) int <- interpolate_rt(out, c(10.5, 11.5, 12.5))  # get the Rt at a single value of lambda interpolate_rt(out, c(10.5, 11.5, 12.5), lambda = out$lambda[20]) #> [1] 1.266720 1.315322 1.363146  y <- c(1, rpois(100, dnorm(1:100, 50, 15) * 500 + 1)) out <- estimate_rt(y, nsol = 10) interpolate_rt(out, xout = c(1.5, 2.5)) #>           [,1]      [,2]      [,3]      [,4]      [,5]     [,6]     [,7] #> [1,] 0.9494042 0.9483473 0.9530090 0.9558256 0.9876951 1.039471 1.180910 #> [2,] 0.9673453 0.9705684 0.9767073 0.9803061 1.0055073 1.039470 1.107582 #>          [,8]     [,9]    [,10] #> [1,] 1.330219 1.473012 1.401269 #> [2,] 1.159646 1.263801 1.475785"},{"path":"https://dajmcdon.github.io/rtestim/reference/plot.cv_poisson_rt.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot cv_poisson_rt — plot.cv_poisson_rt","title":"Plot cv_poisson_rt — plot.cv_poisson_rt","text":"Plot cv_poisson_rt","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/plot.cv_poisson_rt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot cv_poisson_rt — plot.cv_poisson_rt","text":"","code":"# S3 method for class 'cv_poisson_rt' plot(x, which_lambda = c(\"cv_scores\", \"lambda.min\", \"lambda.1se\"), ...)"},{"path":"https://dajmcdon.github.io/rtestim/reference/plot.cv_poisson_rt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot cv_poisson_rt — plot.cv_poisson_rt","text":"x result cv_estimate_rt class cv_poisson_rt which_lambda select Rt's plot. provided, cross validation score plotted. provided list lambda, corresponding Rt estimation plotted. provided string, must either one lambda.min, lambda.1se, cv_scores. provided lambda.min, plot Rt generated lambda minimizes cross validation score. provided lambda.1se, plot Rt generated lambda whose corresponding cross validation score 1 standard error away minimal cross validation score. provided cv_scores, plot cross validation score. NULL, estimated Rt values plotted. ... used.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/plot.cv_poisson_rt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot cv_poisson_rt — plot.cv_poisson_rt","text":"ggplot2::ggplot","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/plot.cv_poisson_rt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot cv_poisson_rt — plot.cv_poisson_rt","text":"","code":"y <- c(1, rpois(100, dnorm(1:100, 50, 15) * 500 + 1)) cv <- cv_estimate_rt(y, korder = 1, nfold = 3, nsol = 30) plot(cv)  plot(cv, which_lambda = cv$lambda[1])  plot(cv, which_lambda = \"lambda.min\")  plot(cv, which_lambda = \"lambda.1se\")  plot(cv, NULL)"},{"path":"https://dajmcdon.github.io/rtestim/reference/plot.poisson_rt.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot estimated Rt values from a poisson_rt object — plot.poisson_rt","title":"Plot estimated Rt values from a poisson_rt object — plot.poisson_rt","text":"Produces figure showing estimated Rt values different values penalty. result ggplot2::ggplot(). Additional user modifications can added desired.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/plot.poisson_rt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot estimated Rt values from a poisson_rt object — plot.poisson_rt","text":"","code":"# S3 method for class 'poisson_rt' plot(x, lambda = NULL, ...)"},{"path":"https://dajmcdon.github.io/rtestim/reference/plot.poisson_rt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot estimated Rt values from a poisson_rt object — plot.poisson_rt","text":"x output function estimate_rt() class poisson_rt lambda select Rt's plot. provided, Rt's plotted. ... used.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/plot.poisson_rt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot estimated Rt values from a poisson_rt object — plot.poisson_rt","text":"ggplot2::ggplot","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/plot.poisson_rt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot estimated Rt values from a poisson_rt object — plot.poisson_rt","text":"","code":"y <- c(1, rpois(100, dnorm(1:100, 50, 15) * 500 + 1)) out <- estimate_rt(y, lambda = log(c(1.1, 1.3, 1.5))) plot(out)"},{"path":"https://dajmcdon.github.io/rtestim/reference/plot.rt_confidence_band.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot estimated confidence bands for an estimate of Rt — plot.rt_confidence_band","title":"Plot estimated confidence bands for an estimate of Rt — plot.rt_confidence_band","text":"Produces figure showing single estimated Rt value along approximate confidence bands. result ggplot2::ggplot(). Additional user modifications can added desired.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/plot.rt_confidence_band.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot estimated confidence bands for an estimate of Rt — plot.rt_confidence_band","text":"","code":"# S3 method for class 'rt_confidence_band' plot(x, colour = \"#3A448F\", ...)"},{"path":"https://dajmcdon.github.io/rtestim/reference/plot.rt_confidence_band.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot estimated confidence bands for an estimate of Rt — plot.rt_confidence_band","text":"x object class rt_confidence_band produced confband(). colour colour desired plot ... used.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/plot.rt_confidence_band.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot estimated confidence bands for an estimate of Rt — plot.rt_confidence_band","text":"ggplot2::ggplot().","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/plot.rt_confidence_band.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot estimated confidence bands for an estimate of Rt — plot.rt_confidence_band","text":"","code":"y <- c(1, rpois(100, dnorm(1:100, 50, 15) * 500 + 1)) out <- estimate_rt(y, nsol = 10) cb <- confband(out, out$lambda[2], level = c(0.95, 0.8, 0.5)) plot(cb)  cb_y <- confband(out, out$lambda[2], level = c(0.95, 0.8, 0.5), type = \"Yt\") plot(cb_y)"},{"path":"https://dajmcdon.github.io/rtestim/reference/predict.cv_poisson_rt.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict observed data using estimated Rt — predict.cv_poisson_rt","title":"Predict observed data using estimated Rt — predict.cv_poisson_rt","text":"Given object class poisson_rt produced estimate_rt(), calculate predicted observed cases estimated Rt values. Note: function intended \"new x\" produce forecasts, rather examine Rt relates observables.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/predict.cv_poisson_rt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict observed data using estimated Rt — predict.cv_poisson_rt","text":"","code":"# S3 method for class 'cv_poisson_rt' predict(object, which_lambda = c(\"lambda.min\", \"lambda.1se\"), ...)"},{"path":"https://dajmcdon.github.io/rtestim/reference/predict.cv_poisson_rt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict observed data using estimated Rt — predict.cv_poisson_rt","text":"object result cross validation type cv_poisson_rt which_lambda Select lambdas object use. provided, Rt's returned. Note new lambdas originally used estimation procedure may provided, results calculated linearly interpolating estimated Rt's. strings lambda.min lambda.1se allowed choose either lambda minimizes cross validation score largest lambda whose corresponding cross validation score within 1 standard error minimal cross validation score. ... used.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/predict.cv_poisson_rt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict observed data using estimated Rt — predict.cv_poisson_rt","text":"vector matrix predicted case counts.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/predict.cv_poisson_rt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict observed data using estimated Rt — predict.cv_poisson_rt","text":"","code":"y <- c(1, rpois(100, dnorm(1:100, 50, 15) * 500 + 1)) cv <- cv_estimate_rt(y, korder = 3, nfold = 3, nsol = 30) p <- predict(cv) p <- predict(cv, which_lambda = cv$lambda[1]) p <- predict(cv, which_lambda = \"lambda.1se\") p <- predict(cv, which_lambda = NULL) plot(y) matlines(p, lty = 2)"},{"path":"https://dajmcdon.github.io/rtestim/reference/predict.poisson_rt.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict observed data using estimated Rt — predict.poisson_rt","title":"Predict observed data using estimated Rt — predict.poisson_rt","text":"Given object class poisson_rt produced estimate_rt(), calculate predicted observed cases estimated Rt values. Note: function intended \"new x\" produce forecasts, rather examine Rt relates observables.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/predict.poisson_rt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict observed data using estimated Rt — predict.poisson_rt","text":"","code":"# S3 method for class 'poisson_rt' predict(object, lambda = NULL, ...)"},{"path":"https://dajmcdon.github.io/rtestim/reference/predict.poisson_rt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict observed data using estimated Rt — predict.poisson_rt","text":"object object class poisson_rt produced estimate_rt(). lambda Select lambdas object use. provided (default), returned. Note new lambdas originally used estimation procedure may provided, results calculated linearly interpolating estimated Rt's. ... used.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/predict.poisson_rt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict observed data using estimated Rt — predict.poisson_rt","text":"vector matrix predicted case counts.","code":""},{"path":"https://dajmcdon.github.io/rtestim/reference/predict.poisson_rt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict observed data using estimated Rt — predict.poisson_rt","text":"","code":"y <- c(1, rpois(100, dnorm(1:100, 50, 15) * 500 + 1)) out <- estimate_rt(y, nsol = 10) preds <- predict(out) plot(y) matlines(preds, lty = 1)"},{"path":"https://dajmcdon.github.io/rtestim/news/index.html","id":"rtestim-development-version","dir":"Changelog","previous_headings":"","what":"rtestim (development version)","title":"rtestim (development version)","text":"Added NEWS.md file track changes package. Account double interval censoring discretize_gamma() #81.","code":""},{"path":"https://dajmcdon.github.io/rtestim/news/index.html","id":"rtestim-100","dir":"Changelog","previous_headings":"","what":"rtestim 1.0.0","title":"rtestim 1.0.0","text":"CRAN release: 2025-07-05 Initial CRAN submission","code":""}]
