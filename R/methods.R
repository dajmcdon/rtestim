

#' Print `poisson_rt` object
#'
#' @param x
#' @param ...
#'
#' @return
#' @exportS3Method print poisson_rt
#'
#' @examples
print.poisson_rt <- function(x, ...) {
  cat("Algorithm convergence status:", x$convergence, "\n")
  cat("With degree:", x$degree, "and lambda:", x$lambda)
}

#' Summary of the `poisson_rt` object
#'
#' @param object
#' @param ...
#'
#' @return
#' @exportS3Method summary poisson_rt
#'
#' @examples
summary.poisson_rt <- function(object, ...) {
  res <- list(
    Time = object$x, # This need to change, it shows (x - x[1]) / diff(range(x)) * n
    Observed_time_points = object$observed_counts,
    R_rate = object$Rt,
    Predicted_cases = object$Rt * object$weighted_past_counts
  )

  class(res) = "summary.poisson_rt"
  return(res)
}

#' Plot `poisson_rt` object
#'
#' @param x output of function `estimate_rt` of class `poisson_rt`
#' @param which_lambda plot Rt that are generated by which lambda or which set of
#' lambdas
#' @param ...
#'
#' @return plot of all or selected Rt from an object of class `poisson_rt`
#' @exportS3Method
#'
#' @examples
#' y <- c(1, rpois(100, dnorm(1:100, 50, 15)*500 + 1))
#' out <- estimate_rt(y, lambda = log(c(1.1,1.3,1.5)))
#' plot(out)
plot.poisson_rt <- function(x, which_lambda = NULL, ...) {
  arg_is_numeric(which_lambda, allow_null = TRUE)
  Rt <- x$Rt
  lambda <- x$lambda

  if (!is.null(which_lambda)) {
    if (!all(which_lambda %in% lambda))
      cli::cli_abort("Can only plot for lambda that already existed")
    idx <- which(lambda %in% which_lambda)
    Rt <- Rt[, idx]
    lambda <- lambda[idx]
  }

  plt_color <- c(1:length(lambda))

  par(mar = c(5, 4, 4, 8), xpd = TRUE)
  matplot(Rt, type = "l", lty = 1, col = plt_color, main = "Estimated Rt",
          xlab = "Time")
  legend("topright", inset=c(-0.21, 0),
         legend = round(lambda, 3), title = "Penalty(lambda)", lty = 1,
         col = plt_color)
}
